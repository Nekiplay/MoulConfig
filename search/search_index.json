{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"MoulConfig MoulConfig is a mod configuration GUI for Minecraft\u2122 mods. It was originally developed by Moulberry , and is now mostly maintained by nea89 . The original code was available under an LGPL 3.0 license, and this version keeps that license. Installation This version of MoulConfig is published to the NEU Maven Repository . The latest version number can be found there as well . There are two versions of MoulConfig: legacy for 1.8.9 and modern for 1.20.2. Legacy has support for the config gui and for the gui library, while modern only supports the gui library. Legacy installation On 1.8.9 Forge you will need to shadow MoulConfig like any other mod dependency. It is highly recommended that you relocate MoulConfig to another package, since our internals do not obey any backwards compatibility guarantees. In order to get resources loaded in your development environment is is recommended that you also make use of the io.github.moulberry.moulconfig.tweaker.DevelopmentResourceTweaker . Do not specify this tweaker in your JAR manifest, only as a command line argument during development time. See a snippet on how to use MoulConfig with architectury loom below: repositories { maven(\"https://maven.notenoughupdates.org/releases/\") } // Your gradle template probably already includes something like this configuration. // **Make sure that the configuration is extending modImplementation, otherwise you will run into name issues** val shadowModImpl by configurations.creating { configurations.modImplementation.get().extendsFrom(this) } dependencies { // Where shadowModImpl is a gradle configuration that remaps and shades the jar. \"shadowModImpl\"(\"org.notenoughupdates.moulconfig:legacy:<version>\") } // This snippet is required in order to correctly load resources in the development environment loom { launchConfigs { \"client\" { arg(\"--tweakClass\", \"io.github.moulberry.moulconfig.tweaker.DevelopmentResourceTweaker\") } } } tasks.shadowJar { // Make sure to relocate MoulConfig to avoid version clashes with other mods configurations = listOf(shadowModImpl) relocate(\"io.github.moulberry.moulconfig\", \"my.mod.deps.moulconfig\") } Modern installation Just shadow MoulConfig like any other mod. It is highly recommended that you relocate MoulConfig to another package, since our internals do not obey any backwards compatibility guarantees. No other buildscript configuration is necessary. repositories { maven(\"https://maven.notenoughupdates.org/releases/\") } // Your gradle template probably already includes something like this configuration. // **Make sure that the configuration is extending modImplementation, otherwise you will run into name issues** val shadowModImpl by configurations.creating { configurations.modImplementation.get().extendsFrom(this) } dependencies { // Where shadowModImpl is a gradle configuration that remaps and shades the jar. \"shadowModImpl\"(\"org.notenoughupdates.moulconfig:modern:<version>\") } tasks.shadowJar { // Make sure to relocate MoulConfig to avoid version clashes with other mods configurations = listOf(shadowModImpl) relocate(\"io.github.moulberry.moulconfig\", \"my.mod.deps.moulconfig\") } Usage See the TestMod for usage examples, or check out the annotation package documentation to see the kind of config variable editors MoulConfig has built in.","title":"MoulConfig"},{"location":"#moulconfig","text":"MoulConfig is a mod configuration GUI for Minecraft\u2122 mods. It was originally developed by Moulberry , and is now mostly maintained by nea89 . The original code was available under an LGPL 3.0 license, and this version keeps that license.","title":"MoulConfig"},{"location":"#installation","text":"This version of MoulConfig is published to the NEU Maven Repository . The latest version number can be found there as well . There are two versions of MoulConfig: legacy for 1.8.9 and modern for 1.20.2. Legacy has support for the config gui and for the gui library, while modern only supports the gui library.","title":"Installation"},{"location":"#legacy-installation","text":"On 1.8.9 Forge you will need to shadow MoulConfig like any other mod dependency. It is highly recommended that you relocate MoulConfig to another package, since our internals do not obey any backwards compatibility guarantees. In order to get resources loaded in your development environment is is recommended that you also make use of the io.github.moulberry.moulconfig.tweaker.DevelopmentResourceTweaker . Do not specify this tweaker in your JAR manifest, only as a command line argument during development time. See a snippet on how to use MoulConfig with architectury loom below: repositories { maven(\"https://maven.notenoughupdates.org/releases/\") } // Your gradle template probably already includes something like this configuration. // **Make sure that the configuration is extending modImplementation, otherwise you will run into name issues** val shadowModImpl by configurations.creating { configurations.modImplementation.get().extendsFrom(this) } dependencies { // Where shadowModImpl is a gradle configuration that remaps and shades the jar. \"shadowModImpl\"(\"org.notenoughupdates.moulconfig:legacy:<version>\") } // This snippet is required in order to correctly load resources in the development environment loom { launchConfigs { \"client\" { arg(\"--tweakClass\", \"io.github.moulberry.moulconfig.tweaker.DevelopmentResourceTweaker\") } } } tasks.shadowJar { // Make sure to relocate MoulConfig to avoid version clashes with other mods configurations = listOf(shadowModImpl) relocate(\"io.github.moulberry.moulconfig\", \"my.mod.deps.moulconfig\") }","title":"Legacy installation"},{"location":"#modern-installation","text":"Just shadow MoulConfig like any other mod. It is highly recommended that you relocate MoulConfig to another package, since our internals do not obey any backwards compatibility guarantees. No other buildscript configuration is necessary. repositories { maven(\"https://maven.notenoughupdates.org/releases/\") } // Your gradle template probably already includes something like this configuration. // **Make sure that the configuration is extending modImplementation, otherwise you will run into name issues** val shadowModImpl by configurations.creating { configurations.modImplementation.get().extendsFrom(this) } dependencies { // Where shadowModImpl is a gradle configuration that remaps and shades the jar. \"shadowModImpl\"(\"org.notenoughupdates.moulconfig:modern:<version>\") } tasks.shadowJar { // Make sure to relocate MoulConfig to avoid version clashes with other mods configurations = listOf(shadowModImpl) relocate(\"io.github.moulberry.moulconfig\", \"my.mod.deps.moulconfig\") }","title":"Modern installation"},{"location":"#usage","text":"See the TestMod for usage examples, or check out the annotation package documentation to see the kind of config variable editors MoulConfig has built in.","title":"Usage"},{"location":"config/","text":"Config GUI The config GUI is the main selling point of MoulConfig. Structure The config structure is roughly mapped to Java classes. Each category, subcategory and accordion is its own Java object. The base class needs to extend Config and each field needs to be non-static. This way your config is also easily serializable as a Json Object. MoulConfig is however completely agnostic towards your configs save format. The only requirement is that instances do not get reassigned. So updating the config object after you have processed a config requires that config to be reprocessed (and old MoulConfig to be discarded). Top Level Structure You can specify categories using @Category . You can even nest categories once to create subcategories. Subsubcategories however do not work. public class MyConfig extends Config { @Override public String getTitle() { return \"\u00a7bMyMod Config\"; } @Category(name = \"Category Name\", desc = \"Category Description\") public MyCategory myCategory = new MyCategory(); public static class MyCategory { @Category(name = \"SubCategory\", desc = \"Sub category description\") public MySubCategory subCategory = new MySubCategory(); } } Note that even tho i sometimes use static inner classes, you can have any sort of class (even including non-static inner classes) as your structure. Inside each category Inside each category you can specify config options using @ConfigOption . In addition to the config option which contains meta information like the name, you will need to add another annotation of your choice to specify an editor for that variable. Check out all the annotations . Make sure that you check the Javadoc on each annotation to know which type your field needs to have for it to work. public class MySubCategory { @ConfigOption(name = \"Text Test\", desc = \"Text Editor Test\") @ConfigEditorText public String text = \"Text\"; @ConfigOption(name = \"Number\", desc = \"Slider test\") @ConfigEditorSlider(minValue = 0, maxValue = 10, minStep = 1) public int slider = 0; @ConfigOption(name = \"Key Binding\", desc = \"Key Binding\") @ConfigEditorKeybind(defaultKey = Keyboard.KEY_F) public int keyBoard = Keyboard.KEY_F; } Accordions Sometimes just subcategories are not enough and you will want to group your options even further. @Accordion s allow you to nest options arbitrarily deep. public class MySubCategory { @ConfigOption(name = \"Text Test\", desc = \"Text Editor Test\") @ConfigEditorText public String text = \"Text\"; @Accordion @ConfigOption(name = \"Hehe\", desc = \"hoho\") public MyAccordion myAccordion = new MyAccordion(); public static class MyAccordion { @ConfigOption(name = \"Number\", desc = \"Slider test\") @ConfigEditorSlider(minValue = 0, maxValue = 10, minStep = 1) public int slider = 0; @ConfigOption(name = \"Key Binding\", desc = \"Key Binding\") @ConfigEditorKeybind(defaultKey = Keyboard.KEY_F) public int keyBoard = Keyboard.KEY_F; } } Properties Sometimes you want to listen to changes to a config variable and run some updates based on that. For that you can use Property<T> . Check the Javadoc for more information on how to use Properties.","title":"Config GUI"},{"location":"config/#config-gui","text":"The config GUI is the main selling point of MoulConfig.","title":"Config GUI"},{"location":"config/#structure","text":"The config structure is roughly mapped to Java classes. Each category, subcategory and accordion is its own Java object. The base class needs to extend Config and each field needs to be non-static. This way your config is also easily serializable as a Json Object. MoulConfig is however completely agnostic towards your configs save format. The only requirement is that instances do not get reassigned. So updating the config object after you have processed a config requires that config to be reprocessed (and old MoulConfig to be discarded).","title":"Structure"},{"location":"config/#top-level-structure","text":"You can specify categories using @Category . You can even nest categories once to create subcategories. Subsubcategories however do not work. public class MyConfig extends Config { @Override public String getTitle() { return \"\u00a7bMyMod Config\"; } @Category(name = \"Category Name\", desc = \"Category Description\") public MyCategory myCategory = new MyCategory(); public static class MyCategory { @Category(name = \"SubCategory\", desc = \"Sub category description\") public MySubCategory subCategory = new MySubCategory(); } } Note that even tho i sometimes use static inner classes, you can have any sort of class (even including non-static inner classes) as your structure.","title":"Top Level Structure"},{"location":"config/#inside-each-category","text":"Inside each category you can specify config options using @ConfigOption . In addition to the config option which contains meta information like the name, you will need to add another annotation of your choice to specify an editor for that variable. Check out all the annotations . Make sure that you check the Javadoc on each annotation to know which type your field needs to have for it to work. public class MySubCategory { @ConfigOption(name = \"Text Test\", desc = \"Text Editor Test\") @ConfigEditorText public String text = \"Text\"; @ConfigOption(name = \"Number\", desc = \"Slider test\") @ConfigEditorSlider(minValue = 0, maxValue = 10, minStep = 1) public int slider = 0; @ConfigOption(name = \"Key Binding\", desc = \"Key Binding\") @ConfigEditorKeybind(defaultKey = Keyboard.KEY_F) public int keyBoard = Keyboard.KEY_F; }","title":"Inside each category"},{"location":"config/#accordions","text":"Sometimes just subcategories are not enough and you will want to group your options even further. @Accordion s allow you to nest options arbitrarily deep. public class MySubCategory { @ConfigOption(name = \"Text Test\", desc = \"Text Editor Test\") @ConfigEditorText public String text = \"Text\"; @Accordion @ConfigOption(name = \"Hehe\", desc = \"hoho\") public MyAccordion myAccordion = new MyAccordion(); public static class MyAccordion { @ConfigOption(name = \"Number\", desc = \"Slider test\") @ConfigEditorSlider(minValue = 0, maxValue = 10, minStep = 1) public int slider = 0; @ConfigOption(name = \"Key Binding\", desc = \"Key Binding\") @ConfigEditorKeybind(defaultKey = Keyboard.KEY_F) public int keyBoard = Keyboard.KEY_F; } }","title":"Accordions"},{"location":"config/#properties","text":"Sometimes you want to listen to changes to a config variable and run some updates based on that. For that you can use Property<T> . Check the Javadoc for more information on how to use Properties.","title":"Properties"}]}